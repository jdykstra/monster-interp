	.IF ~LSTBOOT
	 .NOLIST
	.ELSE
	 .LIST
	.ENDC

	DEF_CH



;Copyright (c) 1978
;  by the Regents of the University of California, San Diego
;
;  The following modifications have been made by John Dykstra:
;
;	30 Dec 84 - Display a message if there is no SYSTEM.PASCAL on the
;		    bootstrap disk.
;	05-Apr-82 - Accept byte pointer to top of memory
;	12-Dec-81 - Interface to standard bootstrap
;

; Beginning of file BOOT


;****************BOOTSTRAP LOADERS****************;

;    The special TEK bootstrap, which is for files that include both
;	the interpreter and the P-code program to execute.

	.IF	TEK
QWIK	; Assume p-code at 2000H, move to high core
	LD	HL,(2006H)	; Get code length (bytes)
	EX	DE,HL
	LD	HL,(MEMTOP)	; Get maximum memory address
	SUBHLDE			; Get address to transfer program to
	LD	SP,HL		; Stack grows from here
	LD	DE,2200H	; Address of start of p-code
	LD	BC,(2006H)	; Set byte counter to # of bytes to transfer
	CLRA			; Get
	SUB	C		;  negative
	LD	C,A		;   byte
	LD	A,00H		;    count
	SBC	A,B		  ;
	LD	B,A

$10	LD	A,(DE)		; Get byte to transfer
	LD	(HL),A		; Move byte to new home
	INC	DE		; Bump address
	INC	HL		; Bump destination address
	INC	C		; Increment lower part of byte count
	JP	NZ,$10		; Overflow into upper byte ?
	INC	B		; Yes, increment upper one, too
	JP	NZ,$10		; Are we done (BC=0) ?
	DEC	HL		; Yes, adjust HL for
	DEC	HL		;  STEP5 of booter
	JP	STEP5		; COWABUNGA !!!!!
	.ENDC

;    The complex bootstrap.  So termed not because it is complex, but
;	because the primary booter that read in the interpreter also
;	initialized the P-machine, in a like manner to the booter below

CBOOT	POP	HL		; get UCSD bios location...
	LD	(BIOSJP),HL	; ...save it in a fixed place...
	JP	BACK1		; ...and start interpreting


;    The standard booter.  For primary booters that simply read in the interp
; This is a Pascal-system loader, it assumes that
;the complete interpreter and booter have been
;loaded by the host machine. It assumes that on
;unit 4 ,block 2 is a directory with the pascal
;operating system 'SYSTEM.PASCAL'. The booter
;reads this, initializes the interpreter to enter
;the system outer block and goes to it.

;     Six easy steps toward the realization of Pascal.
;  1: initialize all I/O drivers, size memory
;  2: read directory, find 'SYSTEM.PASCAL'
;  3: read block zero and set up SEGTBL
;  4: read in segment zero
;  5: set up machine state for seg 0 proc 1
;  6: GO FOR IT.

	; These declarations are for Step 2.
SYSTLE	.BYTE	0DH		;length byte of String
	.ASCII	"SYSTEM.PASCAL" ;characters of String

NOSYSMSG .ASCII "SYSTEM.PASCAL is not on bootstrap disk.  "
	.ASCII	"Bootstrap aborted."
L_NSMSG .EQU	$-NOSYSMSG	; LENGTH OF MESSAGE

DENTSZ	.EQU	1AH		;directory entry size, bytes
DTITLE	.EQU	06H		;offset of title in an entry
DENTP	.WORD	0		;gets set by this Step

SYSBLK	.WORD	0
SEGCNT	.BYTE	0

;  Begin the bootstrap.
;
;  We enter here through the jump located just after the opcode dispatch
;  table at the beginning of the interpreter.  On entry, HL contains
;  a pointer to the top available byte in read/write memory, and
;  A contains the number of the bootstrap unit.

BOOT	;Start here and follow the yellow brick road.

	LD	SP,RELSEG+1000H ; Set temporary SP

	PROGRESS "Q"

	LD	A,0FEH		; MAKE BYTE ADDRESS INTO WORD ADDRESS
	AND	L
	LD	L,A
	LD	(MEMTOP),HL	; remember the top of memory

	LD	A,7		; convert to UCSD unit number    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ADD	A,B
	LD	(SYSUNT),A	;  becomes the system unit number

	;   Step 1
;Initialize all I/O drivers, size memory, and do any other
;  machine-specific stuff needed.

	CALL	IOINIT
	PROGRESS "R"

	.IF CML			; until we update COMPAL files
	 LD	A,0C3H		; set up keyboard interrupt vecto
	 LD	(38H),A
	 LD	HL,CHINT
	 LD	(39H),HL
	.ENDC


;   Step 2
;read directory from abs block 2 into
;memory just above the interp
;find system.pascal and leave the
;address of its direntry in DENTP
;
;	read in the directory
	LD	HL,(SYSUNT)	;unit number for booting
	PUSH	HL
	LD	HL,NRPTOP	;I/O buffer, way out there
	PUSH	HL
	LD	HL,0
	PUSH	HL
	LD	HL,04H*200H	;length, 4 blocks
	PUSH	HL
	LD	HL,02H		;DIR starts at block 2
	PUSH	HL
	CALL	SYSRD		; that does it folks
;	search dir
	LD	HL,FSTENT	 ;skip over entry 0, disk name
	LD	(DENTP),HL
	LD	C,00H
;		;(DENTP)=^DIR ENTRY, HL=^DIR.TITLE, DE=^SYSTITLE, C=counter
$20	;outer, loop on each dir entry
	PROGRESS "S"
	LD	DE,DTITLE	;inc HL to .TITLE in entry
	ADD	HL,DE
	LD	DE,SYSTLE	;set DE to title for comparison
	LD	B,0EH		;comp for length of title
$30	;inner, loop on characters
	LD	A,(DE)
	CP	(HL)
	JP	NZ,$40
	INC	DE
	INC	HL
	DJNZM	$30
	JP	FOUND
$40	; No match here - go to next dir entry
	LD	HL,(DENTP)
	LD	DE,DENTSZ
	ADD	HL,DE
	LD	(DENTP),HL
	DEC	C
	JP	NZ,$20
;
;  We did not find SYSTEM.PASCAL in the directory, so put out an error message
;  and hang.
;
	LD	HL,NOSYSMSG	; DISPLAY ERROR MESSAGE
	LD	BC,L_NSMSG
	MTRREQ	M_DSPTXT

$45	JR	$45		; HANG FOREVER



FOUND	;adrs left in DENTP



;   Step 3
;RELSEG .EQU	NRPTOP+800H	;address to read block 0 at, above dir
;SYSBLK .WORD	0		;amount to make rel seg blk nos absolute
;SEGCNT .BYTE	0

	;do the read
	PROGRESS "T"
	LD	HL,(SYSUNT)	;unit
	PUSH	HL
	LD	HL,RELSEG	;buffer
	PUSH	HL
	LD	HL,0
	PUSH	HL
	LD	HL,40H		;length, 16 entries
	PUSH	HL
	LD	HL,(DENTP)	;block, from directory
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	PUSH	BC
	LD	L,C
	LD	H,B
	LD	(SYSBLK),HL
	CALL	SYSRD
	;put stuff into SEGTBL
;			HL => RELSEG: array [0..15] of
;					DISKADR, relative block number
;					CODELEN	 length in bytes
;			DE => SEGTBL: array [0..15] of
;					UNIT, device index
;					BLOCK, absolute
;					LENGTH same as above
	PROGRESS "U"
	LD	A,10H		;loop control
	LD	(SEGCNT),A
	LD	DE,SEGTBL
	LD	HL,RELSEG
$50	LD	A,(SYSUNT)	;set SEGTBL.UNIT := 4
	LD	(DE),A
	INC	DE
	XOR	A
	LD	(DE),A
	INC	DE
	LD	C,(HL)		;BC := RELSEG.DISKADR
	INC	HL
	LD	B,(HL)
	INC	HL
	PUSH	HL		;calc abs block num
	LD	HL,(SYSBLK)
	ADD	HL,BC
	EX	DE,HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	EX	DE,HL		;restore pointers
	POP	HL
	LD	A,(HL)		;set SEGTBL.LENGTH := RELSEG.CODELEN
	LD	(DE),A
	INC	DE
	INC	HL
	LD	A,(HL)
	LD	(DE),A
	INC	DE
	INC	HL
	LD	A,(SEGCNT)	;do this 16 times
	DEC	A
	LD	(SEGCNT),A
	JP	NZ,$50



;   Step 4
; read segment zero, pointed at by SEGTBL[0],
;into the highest memory address possible, up
;to MAXADR. Also set SP at bottom of code read in.

	PROGRESS "V"
	LD	HL,SEGTBL+04H	;get len of seg zero
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(MEMTOP)
	INC	HL
	INC	HL
	SUBHLDE
	LD	SP,HL
	LD	A,(SYSUNT)	;unit
	LD	C,A
	LD	B,00H
	PUSH	BC
	PUSH	HL		;buffer
	LD	HL,0
	PUSH	HL
	PUSH	DE		;length
	LD	HL,(SEGTBL+02H) ; block
	PUSH	HL
	CALL	SYSRD

; Fill in internal seg table
	PROGRESS "W"
	LD	HL,INTSEGT+4
	LD	BC,-<MAXSEG*4>
	CLRA
$60	LD	(HL),A
	INC	HL
	INC	C
	JP	NZ,$60
	INC	B
	JP	NZ,$60
	LD	HL,1		; initialize entries for op sys
	LD	(INTSEGT),HL
	LD	HL,(MEMTOP)
	LD	(INTSEGT+2),HL


;   Step 5
; Initialize all P-machine registers including
;SP, NP, MP, BASE, IPC, JTAB, SEG.
;Create an initial stack frame and MSCW including
;the automagic ^SYSCOM parameter.

	LD	HL,(MEMTOP)
STEP5	LD	(SEGP),HL
	DEC	HL		;set JTAB := SEG^[-1]
	LD	B,(HL)
	DEC	HL
	LD	C,(HL)
	SUBHLBC			; self relative
	LD	(JTAB),HL
	DEC	HL		;set IPCSAV := JTAB^[-1]
	LD	B,(HL)
	DEC	HL
	LD	C,(HL)
	SUBHLBC			; self relative
	LD	(IPCSAV),HL
	LD	HL,(JTAB)	;new stack frame
	LD	BC,DATASZ
	ADD	HL,BC		; SP := SP-JTAB^[-8]
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	XOR	A
	SUB	C
	LD	L,A
	LD	A,00H
	SBC	A,B
	LD	H,A
	ADD	HL,SP
	LD	SP,HL
	LD	DE,SYSCOM	;^SYSCOM parameter
	PUSH	DE
	PUSH	HL		;create MSCW, dummy save state
	LD	HL,-04H		;address of an ABORT opcode
	ADD	HL,SP
	PUSH	HL
	LD	HL,00D6H	; an ABORT opcode
	PUSH	HL
	PUSH	HL
	LD	HL,-04H		;STAT and DYN must be self referencing
	ADD	HL,SP
	PUSH	HL
	PUSH	HL
	LD	(MP),HL		;set all MSCW pointers
	LD	(BASE),HL
	LD	BC,DISP0
	ADD	HL,BC
	LD	(MPD0),HL
	LD	(BASED0),HL
	LD	HL,INTEND		;set NP
	LD	(NP),HL



;   Step 6
; enable interrupts and do other junky stuff

	PROGRESS "X"

	RESTORE

	.PAGE
;*        SUBROUTINE SHOWPROG - DISPLAY A PROGRESS INDICATOR
;
;  OUTPUT A SINGLE CHARACTER, FOLLOWED BY <CR><LF>.
;
;         ENTRY - PARAMETER IN C REGISTER.
;
;         EXIT - ALL REGISTERS PRESERVED.
;
	.IF	DEBUG
SHOWPROG
        PUSH    IX              ; SAVE ALL USER REGISTERS
        PUSH    IY
        PUSH    HL
        PUSH    DE
        PUSH    BC
        PUSH    AF

        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER
	LD	C,CH_CR
        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER
	LD	C,CH_LF
        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER

        MTRREQ	M_KBCHAR	; WAIT FOR USER

        POP     AF              ; RESTORE USER REGISTERS
        POP     BC
        POP     DE
        POP     HL
        POP     IY
        POP     IX

	RET
	.PAGE

;*        SUBROUTINE HEXOUT - WRITE OUT ONE BYTE IN HEX
;
;  TRANSLATE THE PARAMETER BYTE INTO TWO HEXIDECIMAL
;  CHARACTERS, AND WRITE THEM TO THE USER.
;
;         ENTRY - PARAMETER IN A REGISTER.
;
;         EXIT - A REGISTER DESTROYED.
;                ALL OTHERS PRESERVED.
;

HEXOUT
        PUSH    AF              ; SAVE PARAMETER FOR LATER
        SRL     A               ; RIGHT-JUSTIFY TOP DIGIT
        SRL     A
        SRL     A
        SRL     A
        CP      10.             ; IS IT NUMERIC
        JR      C,HEXOUTA       ; YES.  JUMP
        ADD     A,7             ; BOOST NUMBER
HEXOUTA
        ADD     A,"0"           ; MAKE INTO  ASCII
        CALL    OUTPUTCH        ; WRITE TOP NIBBLE

        POP     AF              ; GET BACK NUMBER
        AND     0FH             ; SAVE LOW DIGIT
        CP      10.             ; IT IS NUMERIC
        JR      C,HEXOUTB       ; YES.  JUMP
        ADD     A,7             ; BOOST NUMBER
HEXOUTB
        ADD     A,"0"           ; MAKE INTO ASCII
        CALL    OUTPUTCH        ; WRITE OUT BOTTOM DIGIT

        RET     	        ; AND  RETURN TO CALLER
        .PAGE
;*        SUBROUTINE TXTOUT - WRITE TEXT BLOCK TO USER
;
;  TRANSFER A TEXT STRING TERMINATED BY AN ETX CHARACTER TO
;  THE USER.
;
;         ENTRY - ADDRESS OF FIRST CHARACTER OF STRING IN HL
;
;         EXIT - HL POINTS TO ETX CHARACTER.
;                A CONTAINS -CH.ETX-
;                ALL OTHER REGISTERS ARE PRESERVED.
;
TXTOUT
        LD      A,(HL)          ; GET NEXT CHARACTER IN TEXT
        CP      CH_ETX          ; IS IT END-OF-TEXT
        RET     Z               ; RETURN IF IT IS END-OF-TEXT

        CALL    OUTPUTCH        ; WRITE OUT CHARACTER
        INC     HL              ; BUMP TEXT POINTER
        JR      TXTOUT          ; AND LOOP FOR NEXT CHARACTER
        .PAGE
;*        SUBROUTINE OUTPUTCH
;
;  WRITE ONE CHARACTER FROM REGISTER A TO THE
;  DISPLAY.
;
;         ENTRY - CHARACTER IN A
;
;         EXIT - ALL REGISTERS PRESERVED
;
OUTPUTCH
        PUSH    IX              ; SAVE ALL USER REGISTERS
        PUSH    IY
        PUSH    HL
        PUSH    DE
        PUSH    BC
        PUSH    AF

        LD      C,A             ; MOVE CHARACTER TO C REGISTER
        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER

        POP     AF              ; RESTORE USER REGISTERS
        POP     BC
        POP     DE
        POP     HL
        POP     IY
        POP     IX

        RET
	.ENDC


NRPTOP	.EQU	$
RELSEG	.EQU	NRPTOP+800H
FSTENT	.EQU	NRPTOP+DENTSZ

	.END	GOLOC		;you learn to pray.

; End of file BOOT, and end of interpreter !


