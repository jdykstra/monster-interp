
	.IF ~LSTIO
	 .NOLIST
	.ELSE
	 .LIST
	.ENDC

;Copyright (c)	1978  by the
;  Regents of the University of California
;  San Diego Campus
;
;  Modifications made by John Dykstra:
;
;	12-Dec-81 - Interface to a BIOS at a fixed location
;	09-Jan-82 - Use direct MONITOR calls for character I/O
;	10-Jan-82 - Use MONITOR calls for disk I/O
;	22-Jan-82 - Add the disk array, code for large sectors
;	23 Feb 83 - Issue correct error code for CRC error
;	19 Nov 83 - Speed up display output by special-casing code
;	11 Feb 84 - Switch disk formats on the fly
;	15 Dec 84 - Use new monitor call to write to printer
;	18 Dec 84 - Support tick clock
;	30 Dec 84 - Do not try to echo keyboard function keys.
;	01 Dec 15 - Add IDE disk support



; Start of file MONIO

;**********************************************************

ABORT	JP	ABORT

TIM	; Time(var hitime, lotime:integer)
	;
	;

	MTRREQ	M_RDCLK

	EX	(SP),HL			; move pointer to hl
	POP	BC			; low clock in BC
	LD	(HL),C
	INC	HL
	LD	(HL),B

	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D

	RESTORE


;******************UNITIO


MAXU	.EQU	12.
INBIT	.EQU	01H
OUTBIT	.EQU	02H
CLRBIT	.EQU	04H
ALLBIT	.EQU	INBIT|OUTBIT|CLRBIT

ASYBIT	.EQU	1
DSKBIT	.EQU	2
EOFBIT	.EQU	4
DLEBIT	.EQU	4
CRLFBIT .EQU	8
;
;  NOTE - THIS CODE DEPENDS UPON THE FACT THAT THE MAPPING CODE FOR
;	  UCSD MAPPING IS 20H AND THE CODE FOR OPTIMIZED MAPPING IS
;	  30H.	WE TEST BIT 4 TO DISTINGUISH BETWEEN THE TWO.
;
FMTSM	.EQU	MAPUCSD+RQSIZ1		; FORMAT CODE FOR SMALL SECTORS
FMTBG	.EQU	MAPOPT+RQSIZ5+V_DRQDDN	; FORMAT CODE FOR BIG SECTORS
FMTIDE	.EQU	0			; FORMAT CODE FOR IDE DRIVES

L_SMSEC .EQU	128.		; LENGTH OF A SMALL DISK SECTOR
L_BGSEC .EQU	512.		; LENGTH OF A BIG DISK SECTOR

C_DRQSZ .EQU	C_DRQCNT	; OFFSET WITHIN REQUEST BLOCK OF SEC SIZE

E_BADDEN .EQU	60H		; DENSITY MISMATCH ERROR

; the unittable unithandler vectors

UNITBL	.EQU	$-04H
	.WORD	ALLBIT		; Unit 1: CONSOLE:
	.WORD	CHDRVR
	.WORD	ALLBIT		; Unit 2: SYSTERM: (non-echoing keyboard)
	.WORD	CHDRVR
	.WORD	00H,00H		; Unit 3: GRAPHICS:
	.WORD	ALLBIT		; Unit 4: drive 0
	.WORD	DR0DRVR
	.WORD	ALLBIT		; Unit 5: drive 1
	.WORD	DR1DRVR
	.WORD	OUTBIT|CLRBIT	; Unit 6: PRINTER:
	.WORD	CHDRVR1
	.WORD	INBIT|CLRBIT	; Unit 7: REMIN:
	.WORD	CHDRVR1
	.WORD	OUTBIT|CLRBIT	; Unit 8: REMOUT:
	.WORD	CHDRVR1
        .WORD   ALLBIT          ; Unit 9: IDE disk 9
        .WORD   DRVR9
        .WORD   ALLBIT          ; Unit 10: IDE disk 10
        .WORD   DRVR10
        .WORD   ALLBIT          ; Unit 11: IDE disk 11
        .WORD   DRVR11
        .WORD   ALLBIT          ; Unit 12: IDE disk 12
        .WORD   DRVR12
; General IO temporaries
UPTR	.EQU	TIO		;points into UNITBL for specific unit
UREQ	.EQU	UPTR+2		;denotes read or write operation
UNIT	.EQU	UREQ+1		;set to LUN of operation
UBUF	.EQU	UNIT+1		;user's buffer address
ULEN	.EQU	UBUF+2		;user's buffer length
UBLK	.EQU	ULEN+2		;block number, for disk I/O
UASY	.EQU	UBLK+2		;async boolean
ASNCBIT .EQU	01H		;applies to the async param
DRCTBIT .EQU	02H		;applies to the async param
URTN	.EQU	UASY+2		;

;  DISK I/O TEMPORARIES
BLKPNT	.EQU   URTN+2		; POINTER TO REQUEST BLOCK
SECCNT	.EQU	BLKPNT+2	; COUNT OF FULL SECTORS TO MOVE
REMLEN	.EQU   SECCNT + 2	; COUNT OF LENGTH REMAINING
SECSZ	.EQU	REMLEN+2	;disk sector size

; Character stream IO temporaries
CLAST	.EQU	URTN+2
CIVECT	.EQU	CLAST+1
COVECT	.EQU	CIVECT+1

; Length of IO temporaries is currently 20 bytes.

;
;  THE DISK ARRAY
;
;  THIS ARRAY CONTAINS POINTERS TO EACH DISK REQUEST BLOCK.  THERE
;  IS A POINTER TO IT IN SYSCOM, AND UTILITIES (PARTICULARLY THE
;  MOUNT COMMAND) USE IT TO EXAMINE AND MODIFY THE OPERATION OF
;  THE DISK DRIVES.
;
DSKARRAY
	.WORD	DRQBLK4		; POINTER FOR UNIT 4
	.WORD	DRQBLK5		; POINTER FOR UNIT 5
	.WORD	DRQBLK9		; POINTER FOR UNIT 9
	.WORD	DRQBLK10	; POINTER FOR UNIT 10
	.WORD	DRQBLK11	; POINTER FOR UNIT 11
	.WORD	DRQBLK12	; POINTER FOR UNIT 12
	.WORD	NIL		; ENTRY RESERVED FOR EXPANSION

; ??  We're starting to use a lot of memory for the disk request blocks.
; ??  Since disk I/O is not overlapped, we really need only one of these
; ??  plus a place to store the configuration state for each unit.
;
;  MONITOR DISK REQUEST BLOCK FOR UCSD UNIT #4:
;
;  NOTE THAT THE DISK REQUEST BLOCKS HAVE AN EXTRA WORD ADDED TO THEIR
;  END WHICH IS NOT A PART OF THE MONITOR DATA STRUCTURE.  THIS WORD
;  CONTAINS THE SECTOR SIZE FOR THE DEVICE, IN BYTES, AND IS USED
;  BY MONIO CODE AS WELL AS SYSTEM UTILITIES THAT ACCESS THE REQUEST
;  BLOCKS THROUGH THE POINTER IN SYSCOM.
;
	.ALIGN	2		; PUT BLOCK ON WORD BOUNDARY
DRQBLK4 .BYTE	0		; PHYSICAL UNIT NUMBER
	.BLOCK	3		; ADDRESSING INFO
	.BYTE	FMTBG		; DISK FORMAT CODE
	.BYTE	0		; FLAGS BYTE
	.BLOCK	4		; MISC INFO
	.BYTE	1		; SECTOR COUNT
	.WORD	L_BGSEC		; SECTOR LENGTH

;
;  MONITOR DISK REQUEST BLOCK FOR UCSD UNIT #5:
;
	.ALIGN	2		; PUT BLOCK ON WORD BOUNDARY
DRQBLK5 .BYTE	1		; PHYISICAL UNIT NUMBER
	.BLOCK	3		; ADDRESSING INFO
	.BYTE	FMTBG		; DISK FORMAT CODE
	.BYTE	0		; FLAGS BYTE
	.BLOCK	4		; MISC INFO
	.BYTE	1		; SECTOR COUNT
	.WORD	L_BGSEC	       	; SECTOR LENGTH

;
;  MONITOR DISK REQUEST BLOCK FOR UCSD UNIT #9:
;
	.ALIGN	2		; PUT BLOCK ON WORD BOUNDARY
DRQBLK9 .BYTE	2+000H		; PHYISICAL UNIT NUMBER + LOGICAL DISK #
	.BLOCK	3		; ADDRESSING INFO
	.BYTE	FMTIDE		; DISK FORMAT CODE
	.BYTE	0		; FLAGS BYTE
	.BLOCK	4		; MISC INFO
	.BYTE	1		; SECTOR COUNT
	.WORD	L_BGSEC	       	; SECTOR LENGTH

;
;  MONITOR DISK REQUEST BLOCK FOR UCSD UNIT #10:
;
	.ALIGN	2		; PUT BLOCK ON WORD BOUNDARY
DRQBLK10 .BYTE	2+000H		; PHYISICAL UNIT NUMBER + LOGICAL DISK #
	.BLOCK	3		; ADDRESSING INFO
	.BYTE	FMTIDE		; DISK FORMAT CODE
	.BYTE	0		; FLAGS BYTE
	.BLOCK	4		; MISC INFO
	.BYTE	1		; SECTOR COUNT
	.WORD	L_BGSEC	       	; SECTOR LENGTH

;
;  MONITOR DISK REQUEST BLOCK FOR UCSD UNIT #11:
;
	.ALIGN	2		; PUT BLOCK ON WORD BOUNDARY
DRQBLK11 .BYTE	3+000H		; PHYISICAL UNIT NUMBER + LOGICAL DISK #
	.BLOCK	3		; ADDRESSING INFO
	.BYTE	FMTIDE		; DISK FORMAT CODE
	.BYTE	0		; FLAGS BYTE
	.BLOCK	4		; MISC INFO
	.BYTE	1		; SECTOR COUNT
	.WORD	L_BGSEC	       ; SECTOR LENGTH

;
;  MONITOR DISK REQUEST BLOCK FOR UCSD UNIT #12:
;
	.ALIGN	2		; PUT BLOCK ON WORD BOUNDARY
DRQBLK12 .BYTE	3+0000H		; PHYISICAL UNIT NUMBER + LOGICAL DISK #
	.BLOCK	3		; ADDRESSING INFO
	.BYTE	FMTIDE		; DISK FORMAT CODE
	.BYTE	0		; FLAGS BYTE
	.BLOCK	4		; MISC INFO
	.BYTE	1		; SECTOR COUNT
	.WORD	L_BGSEC	       	; SECTOR LENGTH




IOC	; IO check - bomb for user IO error if IORSLT <> 0
	LD	HL,(IORSLT)
	LD	A,L
	OR	H
	JP	Z,BACK
	JP	UIOERR

IOR	; IO result - return IORSLT
	LD	HL,(IORSLT)
	PUSH	HL
	RETURN


GETU	;get logical unit number and validate
	XOR	A	;assume operation is going to be valid
	LD	(IORSLT),A
	POP	HL	; get LUN from under the retn adrs
	EX	(SP),HL
	LD	A,L	;0 < LUN <= MAXU ...
	AND	A
	JP	Z,BLUN
	CP	MAXU+1
	JP	NC,BLUN
	LD	(UNIT),A ;save for driver
	ADD	A,A	;times UNITBL elt size
	ADD	A,A
	LD	H,00H
	LD	L,A
	LD	DE,UNITBL ;index into UNITBL
	ADD	HL,DE
	LD	(UPTR),HL ; save this also
	LD	A,(UREQ) ; validate request
	AND	(HL)
	RET	NZ	; and return
BDIR	LD	A,03H	; bad I/O direction
	JP	BOMIT
BLUN	LD	A,02H	; bad unit number
BOMIT	LD	(IORSLT),A
	RET

UBUSY	LD	HL,00H	; assume false ...
	EX	(SP),HL ; and insert under LUN
	PUSH	HL
UWAIT	LD	A,INBIT|OUTBIT
	LD	(UREQ),A
	CALL	GETU
	JP	BACK1	;Boy that was easy.
UCLEAR	LD	A,CLRBIT
	LD	(UREQ),A
	LD	HL,BACK1
	LD	(URTN),HL
	CALL	GETU
	JP	CALLIO
SYSRD	LD	HL,00H
	EX	(SP),HL
	LD	A,INBIT
	JP	SYSIO
UWRITE	LD	A,OUTBIT
	JP	UIO
UREAD	LD	A,INBIT
UIO	LD	HL,BACK1
SYSIO	LD	(UREQ),A
	PROGRESS "#"
	LD	(URTN),HL
	POP	HL	; junk async param
	LD	(UASY),HL
	POP	HL	; put others in param space
	LD	(UBLK),HL
	POP	HL
	LD	(ULEN),HL
	POP	DE
	POP	HL
	ADD	HL,DE
	LD	(UBUF),HL
	CALL	GETU	; get unit number, form table adrs
CALLIO	INC	HL	; get driver adrs from table
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	A,(IORSLT)	; Check for error from GETU
	AND	A
	JR	NZ,IOXIT
;
;  Debug trace of each system and P-machine I/O request.
;
	.IF	DEBUG
	LD	A,(UNIT)
	CALL	HEXOUT
	LD	A,3AH		; ":"
	CALL	OUTPUTCH
	LD	HL,(UBLK)
	CALL	HEXOUTTWO
	LD	A,3AH		; ":"
	CALL	OUTPUTCH
	LD	HL,(UBUF)
	CALL	HEXOUTTWO
	LD	A,3AH		; ":"
	CALL	OUTPUTCH
	LD	HL,(ULEN)
	CALL	HEXOUTTWO
	LD	A,3AH		; ":"
	CALL	OUTPUTCH
	LD	HL,(IORSLT)
	CALL	HEXOUTTWO
	LD	C,75H		"u"
	CALL	SHOWPROG
	.ENDC

	LD	HL,(ULEN)	; check for no bytes
	LD	A,H
	OR	L
	JP	NZ,$10
	LD	A,(UASY)
	AND	DSKBIT
	JP	Z,IOXIT
$10	EX	DE,HL
	JP	(HL)	; GO FOR IT ||
IOXIT	LD	HL,(URTN)
	PROGRESS "-"
	JP	(HL)	; Be see'n you.



;********* DISK DRIVER	***************************


NOUNIT	LD	A,1		; ALL OTHER ERRORS ARE CRC ERRORS
$109	LD	(IORSLT),A	; REPORT ERROR TO P-MACHINE
	JP	IOXIT

DR0DRVR LD	IX,DRQBLK4		; REQUEST BLOCK FOR UNIT 4
	JR	DSK0

DR1DRVR LD	IX,DRQBLK5		; REQUEST BLOCK FOR UNIT 5
	JR	DSK0

DRVR9 LD	IX,DRQBLK9		; REQUEST BLOCK FOR UNIT 9
	JR	DSK0

DRVR10 LD	IX,DRQBLK10		; REQUEST BLOCK FOR UNIT 10
	JR	NOUNIT
	JR	DSK0

DRVR11 LD	IX,DRQBLK11		; REQUEST BLOCK FOR UNIT 11
	JR	NOUNIT
	JR	DSK0

DRVR12 LD	IX,DRQBLK12		; REQUEST BLOCK FOR UNIT 12
					; FALLTHROUGH
	JR	NOUNIT

DSK0	LD	(BLKPNT),IX
	PROGRESS "2"
	.IF	0
	PUSH	IX
	POP	HL
	LD	A,H
	CALL	HEXOUT
	LD	A,L
	CALL	HEXOUT
	LD	A,0FFH1
	CALL	HEXOUT

	LD	C,64H
	CALL	SHOWPROG
	.ENDC
	LD	A,(UREQ)
	AND	CLRBIT
	JP	NZ,XDSK			; IGNORE CLEAR REQUEST

	LD	HL,(ULEN)		; COPY LENGTH INTO REMLEN
	LD	(REMLEN),HL

	LD	A,(IX+C_DRQFMT)		; IDENTIFY DISK FORMAT
	BIT	4,A
	JR	NZ,$01			; Jump if optimized format

	AND	A			; Assume IDE format is zero
	JR	Z,$01			; Jump if IDE

	LD	HL,L_SMSEC		; Remember small sector size
	JR	$02

$01	LD	HL,L_BGSEC		; Remember large sector size
$02	LD	(SECSZ),HL

	LD	A,(UASY)
	AND	DSKBIT		; direct disk accessing ?
	JP	Z,DSKGO
;
;  HANDLE DIRECT DISK ADDRESSING
;
; interpret block # as an absolute sector number, decode it,
;   and send out request
;
;  ?? This doesn't handle IDE yet.
;
	PROGRESS "3"
	LD	HL,(UBLK)
	LD	BC,26.
	CALL	DIVPOS
	LD	(IX+C_DRQTRK),E		; PUT TRACK NUMBER INTO REQ BLK
	INC	L			; SECTOR NUMBERS START AT ONE
	LD	(IX+C_DRQSEC),L		; PUT SECTOR NUMBER INTO REQ BLK
	LD	HL,(UBUF)
	LD	(IX+C_DRQADR),L		; PUT MEM ADR INTO REQ BLK
	LD	(IX+C_DRQADR+1),H
	LD	A,(UREQ)
	AND	INBIT
	JR	Z,$09

	PUSH	IX			; PUT BLK POINTER IN HL
	POP	HL
	MTRREQ	M_DSKRD			; PERFORM THE ACTUAL READ
	JP	XDSK

$09	PUSH	IX			; PUT BLK POINTER IN HL
	POP	HL
	MTRREQ	M_DSKWRT
	JP	XDSK

;
; Start initializing for the loop
; Put size of fractional sector in REMLEN, and count of
; full sectors into SECCNT.
;
DSKGO	LD	HL,(REMLEN)		; COUNT OF BYTES LEFT
	PROGRESS "4"
	LD	A,(IX+C_DRQFMT)		; IDENTIFY DISK FORMAT
	BIT	4,A
	JR	NZ,$13			; JUMP IF OPTIMIZED FORMAT

	AND	A			; ASSUME FMTIDE is zero
	JR	Z,$13			; JUMP IF IDE

;
;  Sector size is 128 bytes.
;
	LD	A,7FH		; ISOLATE FRACTIONAL SECTOR BYTE COUNT
	AND	L
	LD	(REMLEN),A	  ; STORE FRACTION IN REMLEN
	LD	A,0
	LD	(REMLEN+1),A

	ADD	HL,HL		; COMPUTE SECTOR COUNT IN H
	JR	$14		; GO STORE SECTOR COUNT

;
;  COMPUTE FULL SECTOR COUNT AND FRACTIONAL SECTOR BYTE COUNT FOR
;  OPTIMIZED DISK FORMAT AND IDE.  Sector size is 512 bytes.
;
$13	LD	A,1H			; COMPUTE FRACTIONAL BYTE COUNT
	AND	H
	LD	(REMLEN+1),A		  ; PUT COUNT IN REMLEN
	PROGRESS "5"

	SRL	H			; COMPUTE SECTOR COUNT IN H

$14
	INC	H		;adjust for predecr in loop
	LD	A,H			; MOVE COUNT TO A
	LD	(SECCNT),A

	LD	HL,(UBUF)
	LD	(IX+C_DRQADR),L		; STORE MEMORY ADDRESS
	LD	(IX+C_DRQADR+1),H

	LD	A,(IX+C_DRQFMT)		; IDENTIFY DISK FORMAT
	AND	A
	JR	NZ,$15			; JUMP IF NOT IDE

	PROGRESS "a"
	LD	HL,(UBLK)		; GET THE REQUESTED BLOCK #
	LD	(IX+C_DRQTRK),L		; STORE IN REQUEST BLOCK
	LD	(IX+C_DRQTRK+1),H
	JR	$50

$15	LD	HL,(UBLK)	; GET THE REQUESTED BLOCK #
	ADD	HL,HL		; MULTIPLY BLOCK NUMBER BY 4
	ADD	HL,HL
	EX	DE,HL		; PUT REL SECTOR ADR IN DE
	PUSH	IX		; PUT REQ BLK POINTER IN HL
	POP	HL
	MTRREQ	M_DSKADR	; TRANSLATE DISK ADDRESS
	LD	IX,(BLKPNT)	; RESTORE REQ BLK POINTER
;
;  Top of per-sector loop.
;
$50	PROGRESS "b"
	LD	A,(SECCNT)
	DEC	A
	LD	(SECCNT),A
	JP	NZ,$80		; JUMP IF AT LEAST ONE FULL SECTOR TO GO

;
;  Fractional sector special-casing.
;  Jump if we just read or wrote the fractional sector (last of tranfer).
;
	PROGRESS "c"
	LD	HL,(REMLEN)	  ; CHECK FOR FRACTIONAL SECTOR
	BIT	7,H
	JR	NZ,$60		; JUMP IF JUST TRANSFERED A PARTIAL

;
;  Jump if there's a fractional sector yet to do.
;
	PROGRESS "6"
	LD	A,H		; CHECK FOR A PARTIAL YET TO DO
	OR	L
	JP	Z,XDSK		; EXIT IF ALL DONE

;
;  Set up for a fractional sector read or write.
;

	LD	A,1		; PREVENT SECTOR COUNT FROM GOING NEGATIVE
	LD	(SECCNT),A

	SET	7,H		; REMEMBER WE'VE BEEN THRU HERE
	LD	(REMLEN),HL	; Save remainder count plus flag bit

	LD	A,(UREQ)	;do whole sector anyway on output
	AND	OUTBIT
	JP	NZ,$80		; Jump on write

;
;  Allocate a buffer on the stack for the fractional sector read.
;
	LD	HL,-L_BGSEC	; Big sector buffer also enough for small
	ADD	HL,SP
	LD	SP,HL
	LD	(IX+C_DRQADR),L ; SET BUFFER ADDRESS
	LD	(IX+C_DRQADR+1),H
	PROGRESS "7"
	JP	$80		; GO DO THE READ

;
;  Come here after doing fractional read or write of last sector.
;
$60	LD	A,(UREQ)	; Get request code
	AND	OUTBIT
	JP	NZ,XDSK		; Exit if doing a write

	LD	B,H		; MOVE COUNT TO BC
	LD	C,L
	RES	7,B		; CLEAR OUR FLAG BIT
	LD	HL,(UBUF)

	LD	DE,(SECSZ)	; Sector size
	AND	A		; Make sure C flag is clear
	SBC	HL,DE		; COMPENSATE FOR EXTRA BUMP BEFORE
	EX	DE,HL
	LD	HL,0000H
	ADD	HL,SP
	LDIR			; MOVE THE DATA

	LD	HL,L_BGSEC	   ; TAKE THE TEMP BUFFER OFF THE STACK
	ADD	HL,SP
	LD	SP,HL
	JP	XDSK		; And exit

;
;  Here to read or write a full or fractional sector.
;
$80	PROGRESS "8"

;
;  Debug trace of each disk sector transfer.
;
	.IF	DEBUG
	LD	A,(IX+0)
	CALL	HEXOUT

	LD	H,(IX+C_DRQTRK+1)
	LD	L,(IX+C_DRQTRK)
	CALL	HEXOUTTWO
	LD	A,(IX+C_DRQSEC)
	CALL	HEXOUT

	LD	A,3AH		; ":"
	CALL	OUTPUTCH

	LD	H,(IX+C_DRQADR+1)
	LD	L,(IX+C_DRQADR)
	CALL	HEXOUTTWO

	LD	A,3AH		; "s"
	CALL	OUTPUTCH
	LD	HL,CRLF
	CALL	TXTOUT
	.ENDC

	LD	A,(UREQ)	;now finally do the I/O request
	AND	OUTBIT
	JP	Z,$90

	LD	A,M_DSKWRT	 ; WRITE MONITOR REQUEST
	JP	$100

$90	LD	A,M_DSKRD	 ; READ MONITOR REQUEST
$100	PUSH	IX		; PUT REQ BLK ADR IN HL
	POP	HL
	MTRREQ
	PROGRESS "z"
	LD	IX,(BLKPNT)	; RESTORE REQ BLK POINTER

	AND	A		;test for I/O errors from MONITOR
	JP	Z,$110

;
;  PROCESS I/O ERRORS REPORTED BY THE MONITOR.	MOST ERRORS ARE
;  REPORTED TO THE P-MACHINE, BUT DISK TYPE MISMATCHES ARE
;  PROCESSED BELOW.
;
	CP	E_UNTRDY	; CHECK FOR UNIT NOT READY
	JR	NZ,$101

	LD	A,5		; ERROR CODE TO P-MACHINE
	JR	$109

$101	CP	E_WTPROT	; CHECK FOR WRITE-PROTECTED
	JR	NZ,$102

	LD	A,3		; REPORT ILLEGAL I/O REQUEST
	JR	$109

$102	CP	E_BADDEN	; CHECK FOR DENSITY MISMATCH
	JR	Z,$103		; JUMP IF DENSITY MISMATCH

	LD	A,1		; ALL OTHER ERRORS ARE CRC ERRORS
$109	LD	(IORSLT),A	; REPORT ERROR TO P-MACHINE
	JP	$110

;
;  ON DENSITY MISMATCH, CHANGE THE DISK TYPE IN THE REQUEST BLOCK.
;
$103	BIT	4,(IX+C_DRQFMT) ; CHECK BIT IN REQUEST BLOCK
	JR	NZ,$104		; JUMP IF WAS OPTIMIZED FORMAT

	LD	A,FMTBG		; CHANGE FORMAT IN REQUEST BLOCK
	LD	(IX+C_DRQFMT),A

	LD	HL,L_BGSEC	; CHANGE DISK SECTOR LENGTH
	LD	(IX+0BH),L
	LD	(IX+0CH),H

	JR	$105


$104	LD	A,FMTSM		; CHANGE FORMAT IN REQUEST BLOCK
	LD	(IX+C_DRQFMT),A

	LD	HL,L_SMSEC	; CHANGE DISK SECTOR LENGTH
	LD	(IX+0BH),L
	LD	(IX+0CH),H

$105	LD	HL,(ULEN)	; RESET LENGTH
	LD	(REMLEN),HL
	JP	DSKGO

;
;  Here after a successful sector read or write.
;
$110	LD	HL,(UBUF)	; Advance buffer pointer
	LD	DE,(SECSZ)
	ADD	HL,DE
	LD	(UBUF),HL
	LD	(IX+C_DRQADR),L		; UPDATE MEMORY ADR IN REQ BLK
	LD	(IX+C_DRQADR+1),H

	JP	$50			; Loop for next sector

XDSK	PROGRESS "9"
	JP	IOXIT





;************* DRIVER FOR ALL CHARACTER ORIENTED DEVICES  **************
;
;  This table contains the monitor request codes for all character I/O.
;  The entries are in unit number order (unit number 0 is ignored), and
;  consist of the request number for input, followed by the request
;  number for output.
;

CTABLE	.BYTE	00H,00H
	.BYTE	M_KBCHNE,M_DSPCHR		;UNIT 1 (CONSOLE:)
	.BYTE	M_KBCHNE,M_DSPCHR		;UNIT 2 (SYSTERM:)
	.BYTE	00H,00H,00H,00H,00H,00H		;UNITS 3, 4, 5
	.BYTE	00H,M_PTRWRT			;UNIT 6 (PRINTER:)
	.BYTE	M_SRRD,00H			;UNIT 7 (REMIN:)
	.BYTE	00H,M_SRWRT			;UNIT 8 (REMOUT:)



CHDRVR	LD	A,(UREQ)
	AND	CLRBIT
	JP	Z,$10
	; clear out console input stream
	LD	(CLAST),A		;REMEMBER TO LOOK FOR BLANK EXPANSION
	CALL	CHCLR
	JP	CHX



$10	LD	A,(UREQ)		;SEE IF THIS IS AN OUTPUT REQUEST
	AND	OUTBIT
	JR	Z,CH01			;IF NOT, GO PROCESS CHARACTER-BY-CHAR
;
;   HERE WE PROCESS OUTPUT TO THE CONSOLE DEVICE (DISPLAY).  TO SPEED THINGS UP,
;   WE INCLUDE AS MANY CHARACTERS AS POSSIBLE IN EACH CALL TO THE MONITOR.
;   AT THE BEGINNING OF EACH LINE, WE PROCESS BLANK EXPANSION CODES.
;
DISLP	LD	HL,(UBUF)		;POINTER TO OUTPUT STRING
	LD	BC,(ULEN)		;BYTE COUNT

	LD	A,B			;SEE IF BYTE COUNT IS ZERO
	OR	C
	JP	Z,IOXIT			;WE'RE DONE IF COUNT IS ZERO

	LD	A,(HL)			;GET NEXT CHARACTER
	CP	10H			;SEE IF START OF COMPRESSION SEQ.
	JR	NZ,$10			;JUMP IF NOT

	INC	HL			;BUMP POINTER
	LD	A,(HL)			;GET CHAR WITH EXPANSION COUNT
	INC	HL
	LD	(UBUF),HL		;SAVE IN MEMORY
	DEC	BC			;DECREMENT COUNTER
	DEC	BC
	LD	(ULEN),BC

	SUB	20H			;COMPUTE BLANK EXPANSION COUNT
	LD	(CLAST),A		;KEEP BLANK COUNT IN CLAST
;
;  EXPAND BLANK COMPRESSION SEQUENCE.
;
$05	LD	A,(CLAST)		;GET BLANK COUNT
	DEC	A
	JP	M,DISLP			;JUMP IF EXPANSION COMPLETED

	LD	(CLAST),A		;SAVE UPDATED COUNT
	LD	C,20H			;BLANK FOR DISPLAY
	MTRREQ	M_DSPCHR		;DISPLAY IT
	JR	$05			;LOOP FOR MORE


;
;  SCAN THE STRING TO BE DISPLAY FOR A CARRIAGE RETURN CHARACTER.
;
$10	PUSH	HL			;SAVE START OF STRING
	PUSH	BC			;SAVE LENGTH

	LD	A,0DH			;CR CHARACTER
	CPIR				;SCAN STRING
	JR	Z,$20			;JUMP IF CR FOUND

	XOR	A			;REMEMBER CR NOT LAST SEEN

$20	LD	(CLAST),A

	LD	(UBUF),HL		;UPDATE POINTERS IN MEMORY
	LD	(ULEN),BC

	POP	HL			;GET OLD BYTE COUNT
	AND	A			;CLEAR C FLAG
	SBC	HL,BC			;COMPUTE COUNT OF SUB-STRING
	LD	B,H			;MOVE TO BC
	LD	C,L
	POP	HL			;START OF SUBSTRING

	MTRREQ	M_DSPTXT		;DISPLAY SUBSTRING

	LD	A,(CLAST)		;SEE IF SUBSTRING ENDED WITH CR
	AND	A
	JR	Z,$40			;JUMP IF NOT

	LD	A,(UASY)
	AND	CRLFBIT
	JR	NZ,$40			;JUMP IF USER REQUESTED NO LF

	LD	C,0AH			;ADD A LINEFEED TO THE DISPLAY
	MTRREQ	M_DSPCHR

$40	JP	DISLP			;GO LOOK FOR MORE




CHDRVR1 LD	A,(UREQ)
	AND	CLRBIT
	JP	NZ,CHX
CH01	CALL	SETVECT		; set up MONITOR request codes
	LD	HL,(ULEN)	;prepare for loop
	EX	DE,HL
	LD	HL,(UBUF)
$10	LD	A,E	;---LOOP---	length zero yet ?
	OR	D
	JP	Z,CHX
	DEC	DE
	LD	A,(UREQ)	;which direction
	AND	OUTBIT
	JP	Z,$20
	LD	C,(HL)		;do output
	CALL	ECHO
	JP	$30
$20	CALL	CBIS		;do input
	LD	(HL),C
	LD	A,(UASY)
	AND	EOFBIT
	JP	NZ,$28
	LD	A,(SYEOF)	  ; if eof char, zero out rest of request buffer
	CP	(HL)
	JP	NZ,$28
	LD	A,(UNIT)
	CP	1		; CONSOLE: eof means zero buffer, other means
	JP	NZ, CHX		;   simply stop requesting chars
	INC	DE
$25	LD	(HL),0
	DEC	DE
	INC	HL
	LD	A,E
	OR	D
	JP	NZ,$25
	JP	CHX

$28	LD	A,(UNIT)
	CP	01H
	JR	NZ,$30

	LD	A,C		; MAKE SURE THIS CHARACTER IS NOT A FUNCTN KEY
	CP	80H
	CALL	C,ECHO		 ; ECHO THE KEYBOARD CHARACTER

$30	INC	HL
	JP     $10
CHX	JP	IOXIT

ECHO	;char in the Creg is interpreted and output
	LD	A,(UASY)
	AND	DLEBIT
	JP	NZ,$30
$10	LD	A,(CLAST)
	CP	10H	;DLE- blank expansion
	JP	NZ,$30
	LD	A,C
	SUB	20H
	LD	(CLAST),A
$20	LD	A,(CLAST)
	DEC	A
	JP	M,$40
	LD	(CLAST),A
	LD	C,20H
	CALL	CBOS
	JP	$20
$30	LD	A,C
	LD	(CLAST),A
	CP	10H
	JP	NZ,$33
	LD	A,(UASY)
	AND	DLEBIT
	JP	Z,$40
	LD	A,20H		; lie about last char, as dle expansion can
	LD	(CLAST),A	;   occur across uwrite boundaries
$33	CALL	CBOS
	LD	A,(UASY)       ;  don't do lf after cr
	AND	CRLFBIT
	JP	NZ,$40
	LD	A,(CLAST)
	CP	0DH	;CR- requires an LF
	JP	NZ,$40
	LD	A,0AH
	LD	(CLAST),A
	LD	C,A
	CALL	CBOS
$40	RET
;
;  This routine performs the clear function on units 1 and 2.
;  If there is one or more characters buffered up, we discard them.
;

CHCLR	MTRREQ	M_KBSTAT	; get keyboard status
	LD	A,C
	AND	A		; SEE IF THERE IS A CHARACTER WAITING
	RET	Z		; RETURN IF NO CHARACTER WAITING

	MTRREQ	M_KBCHNE	; INPUT (AND DISCARD) KEYBOARD CHARACTER
	JP	CHCLR		; GO SEE IF ANY MORE WAITING

	.IF	DEBUG
CHVECMSG .ASCII	"Character vector = "
	.BYTE	CH_ETX
	.ENDC

SETVECT LD	HL,(UNIT)	;set MONITOR request codes
	LD	H,00H
	ADD	HL,HL
	LD	DE,CTABLE
	ADD	HL,DE
	.IF	DEBUG
	PUSH	HL
	LD	HL,CHVECMSG
	CALL	TXTOUT
	POP	HL
	LD	A,H
	CALL	HEXOUT
	LD	A,L
	CALL	HEXOUT
	PUSH	HL
	LD	HL,CRLF
	CALL	TXTOUT
	POP	HL
	.ENDC
	LD	A,(HL)
	LD	(CIVECT),A		; input operation code
	INC	HL
	LD	A,(HL)
	LD	(COVECT),A		; output operation code
	RET

;routines called by the character driver.
CBIS	LD	A,(CIVECT)
	JP	CBIS1
CBOS	LD	A,(COVECT)
CBIS1	PUSH	HL
	PUSH	DE
	MTRREQ				; call MONITOR to do the I/O
	POP	DE
	POP	HL
	RET

	.PAGE
;*        SUBROUTINE SHOWPROG - DISPLAY A PROGRESS INDICATOR
;
;  OUTPUT A SINGLE CHARACTER, FOLLOWED BY <CR><LF>.
;
;         ENTRY - PARAMETER IN C REGISTER.
;
;         EXIT - ALL REGISTERS PRESERVED.
;
	.IF	DEBUG
SHOWPROG
        PUSH    IX              ; SAVE ALL USER REGISTERS
        PUSH    IY
        PUSH    HL
        PUSH    DE
        PUSH    BC
        PUSH    AF

        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER
	LD	C,CH_CR
        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER
	LD	C,CH_LF
        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER

	MTRREQ	M_KBCHAR	; WAIT FOR USER

        POP     AF              ; RESTORE USER REGISTERS
        POP     BC
        POP     DE
        POP     HL
        POP     IY
        POP     IX

	RET
	.PAGE

;*        SUBROUTINE HEXOUT - WRITE OUT ONE BYTE IN HEX
;
;  TRANSLATE THE PARAMETER BYTE INTO TWO HEXIDECIMAL
;  CHARACTERS, AND WRITE THEM TO THE USER.
;
;         ENTRY - PARAMETER IN A REGISTER.
;
;         EXIT - A REGISTER DESTROYED.
;                ALL OTHERS PRESERVED.
;

HEXOUT
        PUSH    AF              ; SAVE PARAMETER FOR LATER
        SRL     A               ; RIGHT-JUSTIFY TOP DIGIT
        SRL     A
        SRL     A
        SRL     A
        CP      10.             ; IS IT NUMERIC
        JR      C,HEXOUTA       ; YES.  JUMP
        ADD     A,7             ; BOOST NUMBER
HEXOUTA
        ADD     A,"0"           ; MAKE INTO  ASCII
        CALL    OUTPUTCH        ; WRITE TOP NIBBLE

        POP     AF              ; GET BACK NUMBER
        AND     0FH             ; SAVE LOW DIGIT
        CP      10.             ; IT IS NUMERIC
        JR      C,HEXOUTB       ; YES.  JUMP
        ADD     A,7             ; BOOST NUMBER
HEXOUTB
        ADD     A,"0"           ; MAKE INTO ASCII
        CALL    OUTPUTCH        ; WRITE OUT BOTTOM DIGIT

        RET     	        ; AND  RETURN TO CALLER


;*        SUBROUTINE HEXOUTTWO - WRITE OUT TWO BYTES IN HEX
;
;  TRANSLATE THE PARAMETER WORD INTO FOUR HEXIDECIMAL
;  CHARACTERS, AND WRITE THEM TO THE USER.
;
;         ENTRY - PARAMETER IN HL REGISTERS.
;
;         EXIT - A REGISTER DESTROYED.
;                ALL OTHERS PRESERVED.
;

HEXOUTTWO
	LD	A,H
	CALL	HEXOUT
	LD	A,L
	CALL	HEXOUT
	RET

        .PAGE
;*        SUBROUTINE TXTOUT - WRITE TEXT BLOCK TO USER
;
;  TRANSFER A TEXT STRING TERMINATED BY AN ETX CHARACTER TO
;  THE USER.
;
;         ENTRY - ADDRESS OF FIRST CHARACTER OF STRING IN HL
;
;         EXIT - HL POINTS TO ETX CHARACTER.
;                A CONTAINS -CH.ETX-
;                ALL OTHER REGISTERS ARE PRESERVED.
;
TXTOUT
        LD      A,(HL)          ; GET NEXT CHARACTER IN TEXT
        CP      CH_ETX          ; IS IT END-OF-TEXT
        RET     Z               ; RETURN IF IT IS END-OF-TEXT

        CALL    OUTPUTCH        ; WRITE OUT CHARACTER
        INC     HL              ; BUMP TEXT POINTER
        JR      TXTOUT          ; AND LOOP FOR NEXT CHARACTER
        .PAGE
;*        SUBROUTINE OUTPUTCH
;
;  WRITE ONE CHARACTER FROM REGISTER A TO THE
;  DISPLAY.
;
;         ENTRY - CHARACTER IN A
;
;         EXIT - ALL REGISTERS PRESERVED
;
OUTPUTCH
        PUSH    IX              ; SAVE ALL USER REGISTERS
        PUSH    IY
        PUSH    HL
        PUSH    DE
        PUSH    BC
        PUSH    AF

        LD      C,A             ; MOVE CHARACTER TO C REGISTER
        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER

        POP     AF              ; RESTORE USER REGISTERS
        POP     BC
        POP     DE
        POP     HL
        POP     IY
        POP     IX

        RET
	.ENDC


;  Everything past this point is overwritten by the heap
;  once the P-machine starts up.
	.ALIGN	2		; must start on word boundary
INTEND

;  This subroutine is called by the final bootstrap (file BOOT)
;  at the beginning of interpreter execution to initialize
;  the I/O system.
;  Currently, there is really no initialization needed.
;

IOINIT
	RET			; back to booter



; End of file MONIO


