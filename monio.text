	
	.IF ~LSTIO
	 .NOLIST
	.ELSE
	 .LIST
	.ENDC

;Copyright (c)	1978  by the
;  Regents of the University of California
;  San Diego Campus
;
;  Modifications made by John Dykstra:
;
;	12-Dec-81 - Interface to a BIOS at a fixed location
;	09-Jan-82 - Use direct MONITOR calls for character I/O
;	10-Jan-82 - Use MONITOR calls for disk I/O
;	22-Jan-82 - Add the disk array, code for large sectors
;	23 Feb 83 - Issue correct error code for CRC error
;	19 Nov 83 - Speed up display output by special-casing code
;	11 Feb 84 - Switch disk formats on the fly
;	15 Dec 84 - Use new monitor call to write to printer
;	18 Dec 84 - Support tick clock
;	30 Dec 84 - Do not try to echo keyboard function keys.
;



; Start of file MONIO

;**********************************************************

ABORT	JP	ABORT

TIM	; Time(var hitime, lotime:integer) 
	;
	;
	
	MTRREQ	M_RDCLK
	
	EX	(SP),HL			; move pointer to hl
	POP	BC			; low clock in BC
	LD	(HL),C
	INC	HL
	LD	(HL),B
	
	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	
	RESTORE


;******************UNITIO


MAXU	.EQU	07H
INBIT	.EQU	01H
OUTBIT	.EQU	02H
CLRBIT	.EQU	04H
ALLBIT	.EQU	INBIT|OUTBIT|CLRBIT

ASYBIT	.EQU	1
DSKBIT	.EQU	2
EOFBIT	.EQU	4
DLEBIT	.EQU	4
CRLFBIT .EQU	8
;
;  NOTE - THIS CODE DEPENDS UPON THE FACT THAT THE MAPPING CODE FOR
;	  UCSD MAPPING IS 20H AND THE CODE FOR OPTIMIZED MAPPING IS
;	  30H.	WE TEST BIT 4 TO DISTINGUISH BETWEEN THE TWO.
;
FMTSM	.EQU	MAPUCSD+RQSIZ1		; FORMAT CODE FOR SMALL SECTORS
FMTBG	.EQU	MAPOPT+RQSIZ5+V_DRQDDN	; FORMAT CODE FOR BIG SECTORS

L_SMSEC .EQU	128.		; LENGTH OF A SMALL DISK SECTOR
L_BGSEC .EQU	512.		; LENGTH OF A BIG DISK SECTOR

C_DRQSZ .EQU	C_DRQCNT	; OFFSET WITHIN REQUEST BLOCK OF SEC SIZE

E_BADDEN .EQU	60H		; DENSITY MISMATCH ERROR 

; the unittable unithandler vectors

UNITBL	.EQU	$-04H
	.WORD	ALLBIT		; Unit 1: CONSOLE:
	.WORD	CHDRVR
	.WORD	ALLBIT		; Unit 2: SYSTERM: (non-echoing keyboard)
	.WORD	CHDRVR
	.WORD	00H,00H		; Unit 3: GRAPHICS:
	.WORD	ALLBIT		; Unit 4: drive 0
	.WORD	DR0DRVR
	.WORD	ALLBIT		; Unit 5: drive 1
	.WORD	DR1DRVR
	.WORD	OUTBIT|CLRBIT	; Unit 6: PRINTER:
	.WORD	CHDRVR1
	.WORD	INBIT|CLRBIT	; Unit 7: REMIN:
	.WORD	CHDRVR1
	.WORD	OUTBIT|CLRBIT	; Unit 8: REMOUT:
	.WORD	CHDRVR1

; General IO temporaries
UPTR	.EQU	TIO		;points into UNITBL for specific unit
UREQ	.EQU	UPTR+2		;denotes read or write operation
UNIT	.EQU	UREQ+1		;set to LUN of operation
UBUF	.EQU	UNIT+1		;user's buffer address
ULEN	.EQU	UBUF+2		;user's buffer length
UBLK	.EQU	ULEN+2		;block number, for disk I/O
UASY	.EQU	UBLK+2		;async boolean
ASNCBIT .EQU	01H		;applies to the async param
DRCTBIT .EQU	02H		;applies to the async param
URTN	.EQU	UASY+2		;

;  DISK I/O TEMPORARIES
BLKPNT	.EQU   URTN+2		; POINTER TO REQUEST BLOCK
SECCNT	.EQU	BLKPNT+2	; COUNT OF FULL SECTORS TO MOVE
REMLEN	.EQU   SECCNT + 2	; COUNT OF LENGTH REMAINING

; Character stream IO temporaries
CLAST	.EQU	URTN+2
CIVECT	.EQU	CLAST+1
COVECT	.EQU	CIVECT+1

; Length of IO temporaries is currently 20 bytes.

;
;  THE DISK ARRAY
;
;  THIS ARRAY CONTAINS POINTERS TO EACH DISK REQUEST BLOCK.  THERE
;  IS A POINTER TO IT IN SYSCOM, AND UTILITIES (PARTICULARLY THE
;  MOUNT COMMAND) USE IT TO EXAMINE AND MODIFY THE OPERATION OF
;  THE DISK DRIVES.
;
DSKARRAY 
	.WORD	DRQBLK4		; POINTER FOR UNIT 4
	.WORD	DRQBLK5		; POINTER FOR UNIT 5
	.WORD	NIL		; ENTRY RESERVED FOR EXPANSION


;
;  MONITOR DISK REQUEST BLOCK FOR UCSD UNIT #4:
;
;  NOTE THAT THE DISK REQUEST BLOCKS HAVE AN EXTRA WORD ADDED TO THEIR
;  END WHICH IS NOT A PART OF THE MONITOR DATA STRUCTURE.  THIS WORD
;  CONTAINS THE SECTOR SIZE FOR THE DEVICE, IN BYTES, AND IS USED
;  BY MONIO CODE AS WELL AS SYSTEM UTILITIES THAT ACCESS THE REQUEST
;  BLOCKS THROUGH THE POINTER IN SYSCOM.
;
	.ALIGN	2		; PUT BLOCK ON WORD BOUNDARY
DRQBLK4 .BYTE	0		; PHYSICAL UNIT NUMBER
	.BLOCK	3		; ADDRESSING INFO
	.BYTE	FMTBG		; DISK FORMAT CODE
	.BYTE	0		; FLAGS BYTE
	.BLOCK	4		; MISC INFO
	.BYTE	1		; SECTOR COUNT
	.WORD	L_BGSEC		; SECTOR LENGTH

;
;  MONITOR DISK REQUEST BLOCK FOR UCSD UNIT #5:
;
	.ALIGN	2		; PUT BLOCK ON WORD BOUNDARY
DRQBLK5 .BYTE	1		; PHYISICAL UNIT NUMBER
	.BLOCK	3		; ADDRESSING INFO
	.BYTE	FMTBG		; DISK FORMAT CODE
	.BYTE	0		; FLAGS BYTE
	.BLOCK	4		; MISC INFO
	.BYTE	1		; SECTOR COUNT
	.WORD	L_BGSEC	       ; SECTOR LENGTH




IOC	; IO check - bomb for user IO error if IORSLT <> 0
	LD	HL,(IORSLT)
	LD	A,L
	OR	H
	JP	Z,BACK
	JP	UIOERR

IOR	; IO result - return IORSLT
	LD	HL,(IORSLT)
	PUSH	HL
	RETURN


GETU	;get logical unit number and validate
	XOR	A	;assume operation is going to be valid
	LD	(IORSLT),A
	POP	HL	; get LUN from under the retn adrs
	EX	(SP),HL
	LD	A,L	;0 < LUN <= MAXU ...
	AND	A
	JP	Z,BLUN
	CP	MAXU+1
	JP	NC,BLUN
	LD	(UNIT),A ;save for driver
	ADD	A,A	;times UNITBL elt size
	ADD	A,A
	LD	H,00H
	LD	L,A
	LD	DE,UNITBL ;index into UNITBL
	ADD	HL,DE
	LD	(UPTR),HL ; save this also
	LD	A,(UREQ) ; validate request
	AND	(HL)
	RET	NZ	; and return
BDIR	LD	A,03H	; bad I/O direction
	JP	BOMIT
BLUN	LD	A,02H	; bad unit number
BOMIT	LD	(IORSLT),A
	POP	HL
	JP	BACK1

UBUSY	LD	HL,00H	; assume false ...
	EX	(SP),HL ; and insert under LUN
	PUSH	HL
UWAIT	LD	A,INBIT|OUTBIT
	LD	(UREQ),A
	CALL	GETU
	JP	BACK1	;Boy that was easy.
UCLEAR	LD	A,CLRBIT
	LD	(UREQ),A
	LD	HL,BACK1
	LD	(URTN),HL
	CALL	GETU
	JP	CALLIO
SYSRD	LD	HL,00H
	EX	(SP),HL
	LD	A,INBIT
	JP	SYSIO
UWRITE	LD	A,OUTBIT
	JP	UIO
UREAD	LD	A,INBIT
UIO	LD	HL,BACK1
SYSIO	LD	(UREQ),A
	LD	(URTN),HL
	POP	HL	; junk async param
	LD	(UASY),HL
	POP	HL	; put others in param space
	LD	(UBLK),HL
	POP	HL
	LD	(ULEN),HL
	POP	DE
	POP	HL
	ADD	HL,DE
	LD	(UBUF),HL
	CALL	GETU	; get unit number, form table adrs
CALLIO	INC	HL	; get driver adrs from table
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(ULEN)	; check for no bytes
	LD	A,H
	OR	L
	JP	NZ,$10
	LD	A,(UASY)
	AND	DSKBIT
	JP	Z,IOXIT
$10	EX	DE,HL
	JP	(HL)	; GO FOR IT ||
IOXIT	LD	HL,(URTN)
	JP	(HL)	; Be see'n you.



;********* DISK DRIVER	***************************

	

DR0DRVR LD	IX,DRQBLK4		; REQUEST BLOCK FOR UNIT 4   
	JR	DSK0

DR1DRVR LD	IX,DRQBLK5		; REQUEST BLOCK FOR UNIT 5

DSK0	LD	(BLKPNT),IX
	LD	A,(UREQ)
	AND	CLRBIT
	JP	NZ,XDSK			; IGNORE CLEAR REQUEST
	
	LD	HL,(ULEN)		; COPY LENGTH INTO REMLEN
	LD	(REMLEN),HL
	
	LD	A,(UASY)
	AND	DSKBIT		; direct disk accessing ?
	JP	Z,DSKGO
;
;  HANDLE DIRECT DISK ADDRESSING
;
; interpret block # as an absolute sector number, decode it,
;   and send out request
;
	LD	HL,(UBLK)
	LD	BC,26.
	CALL	DIVPOS
	LD	(IX+C_DRQTRK),E		; PUT TRACK NUMBER INTO REQ BLK
	INC	L			; SECTOR NUMBERS START AT ONE
	LD	(IX+C_DRQSEC),L		; PUT SECTOR NUMBER INTO REQ BLK
	LD	HL,(UBUF)
	LD	(IX+C_DRQADR),L		; PUT MEM ADR INTO REQ BLK
	LD	(IX+C_DRQADR+1),H
	LD	A,(UREQ)
	AND	INBIT
	JR	Z,$09
	
	PUSH	IX			; PUT BLK POINTER IN HL
	POP	HL
	MTRREQ	M_DSKRD			; PERFORM THE ACTUAL READ
	JP	XDSK
	
$09	PUSH	IX			; PUT BLK POINTER IN HL
	POP	HL
	MTRREQ	M_DSKWRT
	JP	XDSK 

DSKGO	;Start initializing for the loop
	LD	HL,(REMLEN)
	BIT	4,(IX+C_DRQFMT)		; IDENTIFY DISK FORMAT
	JR	NZ,$13			; JUMP IF OPTIMIZED FORMAT
	
	LD	A,7FH		; ISOLATE FRACTIONAL SECTOR BYTE COUNT
	AND	L
	LD	(REMLEN),A	  ; STORE FRACTION IN REMLEN
	LD	A,0
	LD	(REMLEN+1),A
	
	ADD	HL,HL		; COMPUTE SECTOR COUNT IN H
	JR	$14		; GO STORE SECTOR COUNT
	



;  COMPUTE SECTOR COUNT AND FRACTIONAL SECTOR BYTE COUNT FOR
;  OPTIMIZED DISK FORMAT.
;
$13	LD	A,1H			; COMPUTE FRACTIONAL BYTE COUNT
	AND	H
	LD	(REMLEN+1),A		  ; PUT COUNT IN REMLEN
	
	SRL	H			; COMPUTE SECTOR COUNT IN H

$14	
	INC	H		;adjust for predecr in loop
	LD	A,H			; MOVE COUNT TO A
	LD	(SECCNT),A
	
	LD	HL,(UBUF)
	LD	(IX+C_DRQADR),L		; STORE MEMORY ADDRESS
	LD	(IX+C_DRQADR+1),H
	
	LD	HL,(UBLK)	; GET THE REQUESTED BLOCK #
	ADD	HL,HL		; MULTIPLY BLOCK NUMBER BY 4
	ADD	HL,HL
	EX	DE,HL		; PUT REL SECTOR ADR IN DE
	PUSH	IX		; PUT REQ BLK POINTER IN HL
	POP	HL
	MTRREQ	M_DSKADR	; TRANSLATE DISK ADDRESS
	LD	IX,(BLKPNT)	; RESTORE REQ BLK POINTER
	
$50			;--------LOOP ON SECTORS, Gross Control, Kludge.
	LD	A,(SECCNT)
	DEC	A
	LD	(SECCNT),A
	JP	NZ,$80		; JUMP IF AT LEAST ONE FULL SECTOR TO GO
	 
	LD	HL,(REMLEN)	  ; CHECK FOR FRACTIONAL SECTOR
	BIT	7,H
	JR	NZ,$60		; JUMP IF JUST TRANSFERED A PARTIAL
	
	LD	A,H		; CHECK FOR A PARTIAL YET TO DO
	OR	L
	JP	Z,XDSK		; EXIT IF ALL DONE
	
	LD	A,1		; PREVENT SECTOR COUNT FROM GOING NEGATIVE
	LD	(SECCNT),A
	
	SET	7,H		; REMEMBER WE'VE BEEN THRU HERE
	LD	(REMLEN),HL
	LD	A,(UREQ)	;do whole sector anyway on output
	AND	OUTBIT
	JP	NZ,$80 
	
	LD	HL,-L_BGSEC	   ;fractional read, oh shoot.
	ADD	HL,SP
	LD	SP,HL
	LD	(IX+C_DRQADR),L ; SET BUFFER ADDRESS
	LD	(IX+C_DRQADR+1),H
	JP	$80		; GO DO THE READ
	 
$60	LD	A,(UREQ)	;what happened to the fraction?
	AND	OUTBIT
	JP	NZ,XDSK		;lots to do if read though
	
	LD	B,H		; MOVE COUNT TO BC
	LD	C,L
	RES	7,B		; CLEAR OUR FLAG BIT
	LD	HL,(UBUF)
	BIT	4,(IX+C_DRQFMT)
	JR	NZ,$77		; JUMP IF OPTIMIZED FORMAT
	
	LD	DE,-L_SMSEC
	JR	$78
	
$77	LD	DE,-L_BGSEC

$78	ADD	HL,DE		; COMPENSATE FOR EXTRA BUMP BEFORE
	EX	DE,HL
	LD	HL,0000H
	ADD	HL,SP
	LDIR			; MOVE THE DATA
	
	LD	HL,L_BGSEC	   ; TAKE THE TEMP BUFFER OFF THE STACK
	ADD	HL,SP
	LD	SP,HL
	JP	XDSK
	
$80	LD	A,(UREQ)	;now finally do the I/O request
	AND	OUTBIT
	JP	Z,$90 
	
	LD	A,M_DSKWRT	 ; WRITE MONITOR REQUEST
	JP	$100

$90	LD	A,M_DSKRD	 ; READ MONITOR REQUEST
$100	PUSH	IX		; PUT REQ BLK ADR IN HL
	POP	HL
	MTRREQ
	LD	IX,(BLKPNT)	; RESTORE REQ BLK POINTER
  
	AND	A		;test for I/O errors from MONITOR
	JP	Z,$110
	
;
;  PROCESS I/O ERRORS REPORTED BY THE MONITOR.	MOST ERRORS ARE
;  REPORTED TO THE P-MACHINE, BUT DISK TYPE MISMATCHES ARE 
;  PROCESSED BELOW.
;
	CP	E_UNTRDY	; CHECK FOR UNIT NOT READY
	JR	NZ,$101
	
	LD	A,5		; ERROR CODE TO P-MACHINE
	JR	$109
	
$101	CP	E_WTPROT	; CHECK FOR WRITE-PROTECTED
	JR	NZ,$102
	
	LD	A,3		; REPORT ILLEGAL I/O REQUEST
	JR	$109
	
$102	CP	E_BADDEN	; CHECK FOR DENSITY MISMATCH
	JR	Z,$103		; JUMP IF DENSITY MISMATCH
	
	LD	A,1		; ALL OTHER ERRORS ARE CRC ERRORS
$109	LD	(IORSLT),A	; REPORT ERROR TO P-MACHINE
	JP	$110
	
;
;  ON DENSITY MISMATCH, CHANGE THE DISK TYPE IN THE REQUEST BLOCK.
;
$103	BIT	4,(IX+C_DRQFMT) ; CHECK BIT IN REQUEST BLOCK
	JR	NZ,$104		; JUMP IF WAS OPTIMIZED FORMAT
	
	LD	A,FMTBG		; CHANGE FORMAT IN REQUEST BLOCK
	LD	(IX+C_DRQFMT),A
	
	LD	HL,L_BGSEC	; CHANGE DISK SECTOR LENGTH
	LD	(IX+0BH),L
	LD	(IX+0CH),H
	
	JR	$105
	
	
$104	LD	A,FMTSM		; CHANGE FORMAT IN REQUEST BLOCK
	LD	(IX+C_DRQFMT),A
	
	LD	HL,L_SMSEC	; CHANGE DISK SECTOR LENGTH
	LD	(IX+0BH),L
	LD	(IX+0CH),H
	
$105	LD	HL,(ULEN)	; RESET LENGTH
	LD	(REMLEN),HL
	JP	DSKGO
	



$110	LD	HL,(UBUF)
	BIT	4,(IX+C_DRQFMT)		; CHECK DISK FORMAT TYPE
	JR	NZ,$111			; JUMP IF OPTIMIZED FORMAT
	
	LD	DE,L_SMSEC
	JR	$112
	
	
$111	LD	DE,L_BGSEC		; LARGE SECTOR SIZE
$112	ADD	HL,DE
	LD	(UBUF),HL
	LD	(IX+C_DRQADR),L		; UPDATE MEMORY ADR IN REQ BLK
	LD	(IX+C_DRQADR+1),H
	
	JP	$50	;--------KEEP ON TRUCKIN'.

XDSK	JP	IOXIT





;************* DRIVER FOR ALL CHARACTER ORIENTED DEVICES  **************
;
;  This table contains the monitor request codes for all character I/O.
;  The entries are in unit number order (unit number 0 is ignored), and
;  consist of the request number for input, followed by the request 
;  number for output.
;

CTABLE	.BYTE	00H,00H
	.BYTE	M_KBCHNE,M_DSPCHR		;UNIT 1 (CONSOLE:)
	.BYTE	M_KBCHNE,M_DSPCHR		;UNIT 2 (SYSTERM:)
	.BYTE	00H,00H,00H,00H,00H,00H		;UNITS 3, 4, 5
	.BYTE	00H,M_PTRWRT			;UNIT 6 (PRINTER:)
	.BYTE	M_SRRD,00H			;UNIT 7 (REMIN:)
	.BYTE	00H,M_SRWRT			;UNIT 8 (REMOUT:)
	


CHDRVR	LD	A,(UREQ)
	AND	CLRBIT
	JP	Z,$10
	; clear out console input stream
	LD	(CLAST),A		;REMEMBER TO LOOK FOR BLANK EXPANSION
	CALL	CHCLR
	JP	CHX



$10	LD	A,(UREQ)		;SEE IF THIS IS AN OUTPUT REQUEST
	AND	OUTBIT
	JR	Z,CH01			;IF NOT, GO PROCESS CHARACTER-BY-CHAR
;
;   HERE WE PROCESS OUTPUT TO THE CONSOLE DEVICE (DISPLAY).  TO SPEED THINGS UP,
;   WE INCLUDE AS MANY CHARACTERS AS POSSIBLE IN EACH CALL TO THE MONITOR.
;   AT THE BEGINNING OF EACH LINE, WE PROCESS BLANK EXPANSION CODES.
;
DISLP	LD	HL,(UBUF)		;POINTER TO OUTPUT STRING
	LD	BC,(ULEN)		;BYTE COUNT

	LD	A,B			;SEE IF BYTE COUNT IS ZERO
	OR	C
	JP	Z,IOXIT			;WE'RE DONE IF COUNT IS ZERO
	
	LD	A,(HL)			;GET NEXT CHARACTER
	CP	10H			;SEE IF START OF COMPRESSION SEQ.
	JR	NZ,$10			;JUMP IF NOT
	
	INC	HL			;BUMP POINTER 
	LD	A,(HL)			;GET CHAR WITH EXPANSION COUNT
	INC	HL
	LD	(UBUF),HL		;SAVE IN MEMORY
	DEC	BC			;DECREMENT COUNTER
	DEC	BC
	LD	(ULEN),BC
	
	SUB	20H			;COMPUTE BLANK EXPANSION COUNT
	LD	(CLAST),A		;KEEP BLANK COUNT IN CLAST
;
;  EXPAND BLANK COMPRESSION SEQUENCE.
;
$05	LD	A,(CLAST)		;GET BLANK COUNT
	DEC	A
	JP	M,DISLP			;JUMP IF EXPANSION COMPLETED
	
	LD	(CLAST),A		;SAVE UPDATED COUNT
	LD	C,20H			;BLANK FOR DISPLAY
	MTRREQ	M_DSPCHR		;DISPLAY IT
	JR	$05			;LOOP FOR MORE


;
;  SCAN THE STRING TO BE DISPLAY FOR A CARRIAGE RETURN CHARACTER.  
;
$10	PUSH	HL			;SAVE START OF STRING
	PUSH	BC			;SAVE LENGTH
	
	LD	A,0DH			;CR CHARACTER
	CPIR				;SCAN STRING
	JR	Z,$20			;JUMP IF CR FOUND
	
	XOR	A			;REMEMBER CR NOT LAST SEEN
 
$20	LD	(CLAST),A
	
	LD	(UBUF),HL		;UPDATE POINTERS IN MEMORY
	LD	(ULEN),BC
     
	POP	HL			;GET OLD BYTE COUNT
	AND	A			;CLEAR C FLAG
	SBC	HL,BC			;COMPUTE COUNT OF SUB-STRING
	LD	B,H			;MOVE TO BC
	LD	C,L
	POP	HL			;START OF SUBSTRING

	MTRREQ	M_DSPTXT		;DISPLAY SUBSTRING
	
	LD	A,(CLAST)		;SEE IF SUBSTRING ENDED WITH CR
	AND	A
	JR	Z,$40			;JUMP IF NOT
	
	LD	A,(UASY)		 
	AND	CRLFBIT
	JR	NZ,$40			;JUMP IF USER REQUESTED NO LF
	
	LD	C,0AH			;ADD A LINEFEED TO THE DISPLAY
	MTRREQ	M_DSPCHR
	
$40	JP	DISLP			;GO LOOK FOR MORE




CHDRVR1 LD	A,(UREQ)
	AND	CLRBIT
	JP	NZ,CHX
CH01	CALL	SETVECT		; set up MONITOR request codes	
	LD	HL,(ULEN)	;prepare for loop
	EX	DE,HL
	LD	HL,(UBUF)
$10	LD	A,E	;---LOOP---	length zero yet ?
	OR	D
	JP	Z,CHX
	DEC	DE
	LD	A,(UREQ)	;which direction
	AND	OUTBIT
	JP	Z,$20 
	LD	C,(HL)		;do output
	CALL	ECHO
	JP	$30
$20	CALL	CBIS		;do input
	LD	(HL),C
	LD	A,(UASY)
	AND	EOFBIT
	JP	NZ,$28
	LD	A,(SYEOF)	  ; if eof char, zero out rest of request buffer
	CP	(HL)
	JP	NZ,$28
	LD	A,(UNIT)
	CP	1		; CONSOLE: eof means zero buffer, other means
	JP	NZ, CHX		;   simply stop requesting chars
	INC	DE
$25	LD	(HL),0
	DEC	DE
	INC	HL
	LD	A,E
	OR	D
	JP	NZ,$25
	JP	CHX

$28	LD	A,(UNIT)
	CP	01H
	JR	NZ,$30
	
	LD	A,C		; MAKE SURE THIS CHARACTER IS NOT A FUNCTN KEY
	CP	80H
	CALL	C,ECHO		 ; ECHO THE KEYBOARD CHARACTER

$30	INC	HL
	JP     $10 
CHX	JP	IOXIT

ECHO	;char in the Creg is interpreted and output
	LD	A,(UASY)
	AND	DLEBIT 
	JP	NZ,$30
$10	LD	A,(CLAST)
	CP	10H	;DLE- blank expansion
	JP	NZ,$30
	LD	A,C
	SUB	20H
	LD	(CLAST),A
$20	LD	A,(CLAST)
	DEC	A
	JP	M,$40
	LD	(CLAST),A
	LD	C,20H
	CALL	CBOS
	JP	$20
$30	LD	A,C
	LD	(CLAST),A
	CP	10H
	JP	NZ,$33
	LD	A,(UASY)
	AND	DLEBIT
	JP	Z,$40
	LD	A,20H		; lie about last char, as dle expansion can
	LD	(CLAST),A	;   occur across uwrite boundaries
$33	CALL	CBOS
	LD	A,(UASY)       ;  don't do lf after cr
	AND	CRLFBIT
	JP	NZ,$40
	LD	A,(CLAST)
	CP	0DH	;CR- requires an LF
	JP	NZ,$40
	LD	A,0AH
	LD	(CLAST),A
	LD	C,A
	CALL	CBOS
$40	RET
;
;  This routine performs the clear function on units 1 and 2.
;  If there is one or more characters buffered up, we discard them.
;

CHCLR	MTRREQ	M_KBSTAT	; get keyboard status
	LD	A,C 
	AND	A		; SEE IF THERE IS A CHARACTER WAITING
	RET	Z		; RETURN IF NO CHARACTER WAITING
	
	MTRREQ	M_KBCHNE	; INPUT (AND DISCARD) KEYBOARD CHARACTER
	JP	CHCLR		; GO SEE IF ANY MORE WAITING
	
	

SETVECT LD	HL,(UNIT)	;set MONITOR request codes
	LD	H,00H
	ADD	HL,HL
	LD	DE,CTABLE
	ADD	HL,DE
	LD	A,(HL)
	LD	(CIVECT),A		; input operation code
	INC	HL
	LD	A,(HL)
	LD	(COVECT),A		; output operation code
	RET

;routines called by the character driver.
CBIS	LD	A,(CIVECT)
	JP	CBIS1
CBOS	LD	A,(COVECT)
CBIS1	PUSH	HL
	PUSH	DE
	MTRREQ				; call MONITOR to do the I/O
	POP	DE
	POP	HL
	RET

	

; Booter stuff
	.ALIGN	2		; must start on word boundary
INTEND

;  This subroutine is called by the final bootstrap (file BOOT)
;  at the beginning of interpreter execution to initialize
;  the I/O system.  
;  Currently, there is really no initialization needed.
;

IOINIT	
	RET			; back to booter
	
	
; End of file MONIO

	
